OPTPARSER_NAME=optparser

# data structure
OPTPARSER_NONE=__none___
# optparser
Optparser_prog_name=$(basename $0)
Optparser_overwrited_usage=false
Optparser_prefix_chars=-
Optparser_prologue=''
Optparser_usage_string=''
Optparser_description=''
Optparser_epilog=''
Optparser_add_help=true


function optparser()
{
    # option parameters array
    Optparser_option_strings=()
    Optparser_option_to=()
    Optparser_option_check=()
    Optparser_option_action=()
    Optparser_option_default=()
    Optparser_option_desc=()
    Optparser_option_metavar=()
    Optparser_option_required=()
    Optparser_option_choices=()

	function _parse_parameters()
	{
		local i
		# fetch optparser_to_option_name_pair name
		local optparser_to_option_name_pair=()
		local _pattern='^[_a-zA-Z][_0-9a-zA-Z]*=[_0-9a-zA-Z]*$'
		for i in "$@"; do
			shift
			if [[ $i = -- ]]; then
				break
			fi
			if [[ ! $i =~ $_pattern ]]; then
				optparser_error $OPTPARSER_NAME "invalid parameter: $i" fatal
			fi
			optparser_to_option_name_pair=("${optparser_to_option_name_pair[@]}" "${i/=/ }")
		done
		# parse start
		local _has_get_flag
		for argv in "$@"; do
			_has_get_flag=false
			for i in "${optparser_to_option_name_pair[@]}"; do
				read to_name opt_name <<< "$i"
				if [[ $argv = $opt_name=* ]]; then
					_set2globals "$to_name" "${argv#*=}"
					_has_get_flag=true
					break
				fi
			done
			[[ $_has_get_flag = false ]] && optparser_error $OPTPARSER_NAME "un-capturable argument for your optparser: $argv." error
		done
	}

	function optparser_error()
	{
		local prog=$(tr [a-z] [A-Z] <<< "$1")
		local message=$2
		local error_type=$(tr [A-Z] [a-z] <<< "${3:-error}")
		local no_exit=$4
		printf "$prog: $error_type: "'%s\n' "$message"
		[[ $no_exit ]] || exit 1
	}

	# initial optparser
	if (( $# > 0 )); then
		Optparser_prog_name=$1
		shift
		if (( $# > 0 )); then
			_parse_parameters \
				Optparser_overwrited_usage=overwrited_usage \
				Optparser_prologue=prologue \
				Optparser_usage_string=usage_string \
				Optparser_description=description \
				Optparser_epilog=epilog \
				Optparser_prefix_chars=prefix_chars \
				Optparser_add_help=add_help \
				-- "$@"
		fi
	fi
	# -- initial optparser done

	function optparser_setdefault()
	{
		echo
	}

	function optparser_add_option()
	{
        # fetch option name
		local _pattern='^[-_0-9a-zA-Z]+$'
		local _opt_name=''
		while (( $# > 0 )); do
			[[ $1 = *=* ]] && break
			if [[ ! $1 =~ $_pattern ]]; then
				optparser_error $OPTPARSER_NAME "Invalid option name: $1" error
			fi
			_opt_name="$_opt_name|$1"
			shift
		done
        Optparser_option_strings=("${Optparser_option_strings[@]}" "$_opt_name")

        # fetch other option data
        local _to=''
        local _check=''
        local _action=''
        local _desc=''
        local _metavar=''
        local _required=false
        local _choices=''
        local _default=''
        local _nargs=''
        _parse_parameters \
            _to=to _check=check _action=action \
            _desc=desc _metavar=metavar \
            _default=default _required=required _choices=choices \
            -- "$@"
        Optparser_option_to=("${Optparser_option_to[@]}" "$_to")
        Optparser_option_check=("${Optparser_option_check[@]}" "$_check")
        Optparser_option_action=("${Optparser_option_action[@]}" "$_action")
        Optparser_option_default=("${Optparser_option_default[@]}" "$_default")
        Optparser_option_desc=("${Optparser_option_desc[@]}" "$_desc")
        Optparser_option_metavar=("${Optparser_option_metavar[@]}" "$_metavar")
        Optparser_option_required=("${Optparser_option_required[@]}" "$_required")
        Optparser_option_choices=("${Optparser_option_choices[@]}" "$_choices")
	}

	function optparser_parse()
	{
        # add help option here
        if [[ $Optparser_add_help = true ]]; then
            optparser_add_option -h --help desc="show this help message and exit"
        fi

	}

    function _choose_metavar()
    {
        :
    }

    function _choose_to()
    {
        :
    }

	function optparser_DEBUG()
	{
		echo
	}

	# check API
	# check_callback arg...

	# action API
	# action_callback to value option_string option_strings
    # store|store_const|store_true|store_false|help|?version?

	# stop parsing marker --

}

# dynamically set $variable_name($1)=$values($2...) to globals scope
function _set2globals()
{
    if (( $# < 2 )); then
        printf 'Expect at least 2 argument, but %d you given.' $# >&2
        exit 1
    fi
    local _pattern='^[_a-zA-Z][_0-9a-zA-Z]*$'
    if [[ ! $1 =~ $_pattern ]]; then
        printf 'Invalid variable name: %s\n' "$1" >&2
        exit 1
    fi
    local __variable__name__=$1
    shift
    local i
    local _tmp
    local values=()
    for i in "$@"; do
        _tmp=\'${1//"'"/"'\''"}\'
        values=("${values[@]}" "$_tmp") # push to array
    done

    if (( ${#values[@]} == 1 )); then
        eval $__variable__name__="${values[0]}"
    else
        eval $__variable__name__=\("${values[@]}"\)
    fi
}