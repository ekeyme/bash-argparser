# optparser
Optparser_porg_name=$(basename $0)
Optparser_overwrited_usage=false
Optparser_prefix_chars=-
Optparser_prologue=''
Optparser_usage_string=''
Optparser_description=''
Optparser_epilog=''
Optparser_add_help=true

Optparser_option_names=()


function optparser()
{
	OPTPARSER_NAME=optparser

	function _parse_parameters()
	{
		local i
		# fetch optparser_to_option_name_pair name
		local optparser_to_option_name_pair=()
		local _pattern='^[_a-zA-Z][_0-9a-zA-Z]*=[_0-9a-zA-Z]*$'
		for i in "$@"; do
			shift
			if [[ $i = -- ]]; then
				break
			fi
			if [[ ! $i =~ $_pattern ]]; then
				optparser_error $OPTPARSER_NAME "invalid parameter: $i" fatal
			fi
			optparser_to_option_name_pair=("${optparser_to_option_name_pair[@]}" "${i/=/ }")
		done
		# parse start
		local _has_get_flag
		for argv in "$@"; do
			_has_get_flag=false
			for i in "${optparser_to_option_name_pair[@]}"; do
				read to_name opt_name <<< "$i"
				if [[ $argv = $opt_name=* ]]; then
					_set2globals "$to_name" "${argv#*=}"
					_has_get_flag=true
					break
				fi
			done
			[[ $_has_get_flag = false ]] && optparser_error $OPTPARSER_NAME "un-capturable argument for your optparser: $argv." error
		done
	}

	function optparser_error()
	{
		local prog=$(tr [a-z] [A-Z] <<< "$1")
		local message=$2
		local error_type=$(tr [A-Z] [a-z] <<< "${3:-error}")
		local no_exit=$4
		printf "$prog: $error_type: "'%s\n' "$message"
		[[ $no_exit ]] || exit 1
	}

	# initial optparser
	if (( $# > 0 )); then
		Optparser_porg_name=$1
		shift
		if (( $# > 0 )); then
			_parse_parameters \
				Optparser_overwrited_usage=overwrited_usage \
				Optparser_prologue=prologue \
				Optparser_usage_string=usage_string \
				Optparser_description=description \
				Optparser_epilog=epilog \
				Optparser_prefix_chars=prefix_chars \
				Optparser_add_help=add_help \
				-- "$@"
		fi
	fi
	# -- initial optparser done

	function optparser_setdefault()
	{
		echo
	}

	function optparser_add_option()
	{
		local _pattern='^[0-9a-zA-Z]+$'
		local opt_name_str=''
		while (( $# > 0 )); do
			[[ $1 = *=* ]] && break
			if [[ ! $1 =~ $_pattern ]]; then
				optparser_error $OPTPARSER_NAME "Invalid option name: $1" error
			fi
			opt_name_str="$opt_name_str|$1"
			shift
		done
	}

	function optparser_parse()
	{
		echo
	}

	function optparser_DEBUG()
	{
		echo
	}

	# check API
	# check_callback arg...

	# action API (the same with check)
	# action_callback arg...

	# stop parsing marker --

}

# dynamically set $variable_name($1)=$values($2...) to globals scope
function _set2globals()
{
    if (( $# < 2 )); then
        printf 'Expect at least 2 argument, but %d you given.' $# >&2
        exit 1
    fi
    local _pattern='^[_a-zA-Z][_0-9a-zA-Z]*$'
    if [[ ! $1 =~ $_pattern ]]; then
        printf 'Invalid variable name: %s\n' "$1" >&2
        exit 1
    fi
    local __variable__name__=$1
    shift
    local i
    local _tmp
    local values=()
    for i in "$@"; do
        _tmp=$( _escaping "$i" )
        values=("${values[@]}" "$_tmp") # push to array
    done

    if (( ${#values[@]} == 1 )); then
        eval $__variable__name__="${values[0]}"
    else
        eval $__variable__name__=\("${values[@]}"\)
    fi
}

function _escaping()
{
    local str=${1//"'"/"'\''"}
    echo "'$str'"
}