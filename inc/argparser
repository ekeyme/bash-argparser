ARGPARSER_NAME=argparser

# data structure
ARGPARSER_UNSET=__unset___
# argparser
Argparser_prog_name=$(basename $0)
Argparser_overwrited_usage=false
Argparser_prefix_chars=-
Argparser_prologue=''
Argparser_usage_string=''
Argparser_description=''
Argparser_epilog=''
Argparser_add_help=true

function argparser()
{
    # option parameters array
    Argparser_option_strings=()
    Argparser_option_to=()
    Argparser_option_check=()
    Argparser_option_action=()
    Argparser_option_default=()
    Argparser_option_const=()
    Argparser_option_nargs=()
    Argparser_option_desc=()
    Argparser_option_metavar=()
    Argparser_option_required=()
    Argparser_option_choices=()
    # option_status 
    # 0: Positional Parameter(pp) do not show up in $@, so haven't been parsed
    # 2: pp have been parsed
    # 1: Optional Parameter(op) haven't been parsed
    # 3: op have been parsed
    _Argparser_option_status=()

	function _parse_parameters()
	{
		local i
		# fetch argparser_to_option_name_pair name
		local argparser_to_option_name_pair=()
		local _pattern='^[_a-zA-Z][_0-9a-zA-Z]*=[_0-9a-zA-Z]*$'
		for i in "$@"; do
			shift
			if [[ $i = -- ]]; then
				break
			fi
			if [[ ! $i =~ $_pattern ]]; then
				argparser_error $ARGPARSER_NAME "invalid parameter: $i" fatal
			fi
			argparser_to_option_name_pair=("${argparser_to_option_name_pair[@]}" "${i/=/ }")
		done
		# parse start
		local _has_get_flag
		for argv in "$@"; do
			_has_get_flag=false
			for i in "${argparser_to_option_name_pair[@]}"; do
				read to_name opt_name <<< "$i"
				if [[ $argv = $opt_name=* ]]; then
					_set2globals "$to_name" "${argv#*=}"
					_has_get_flag=true
					break
				fi
			done
			[[ $_has_get_flag = false ]] && argparser_error $ARGPARSER_NAME "un-capturable argument for your argparser: $argv." error
		done
	}

	function argparser_error()
	{
		local prog=$(tr [a-z] [A-Z] <<< "$1")
		local message=$2
		local error_type=$(tr [A-Z] [a-z] <<< "${3:-error}")
		local no_exit=$4
		printf "$prog: $error_type: "'%s\n' "$message" >&2
		[[ $no_exit ]] || exit 1
	}

	# initial argparser
	if (( $# > 0 )); then
		Argparser_prog_name=$1
		shift
		if (( $# > 0 )); then
			_parse_parameters \
				Argparser_overwrited_usage=overwrited_usage \
				Argparser_prologue=prologue \
				Argparser_usage_string=usage_string \
				Argparser_description=description \
				Argparser_epilog=epilog \
				Argparser_prefix_chars=prefix_chars \
				Argparser_add_help=add_help \
				-- "$@"
		fi
	fi
	# -- initial argparser done

    #@to-do add exclusive type
	function argparser_add_option()
	{
        # fetch option name
		local _pattern='^[-_0-9a-zA-Z]+$'
		local _opt_name=''
		while (( $# > 0 )); do
			[[ $1 = *=* ]] && break
			if [[ ! $1 =~ $_pattern ]]; then
				argparser_error $ARGPARSER_NAME "Invalid option name: $1" error
			fi
			_opt_name="$_opt_name|$1"
			shift
		done
        Argparser_option_strings=("${Argparser_option_strings[@]}" "${_opt_name#|}")

        # fetch other option data
        local _to=''
        local _check=''
        local _action=''
        local _desc=''
        local _metavar=''
        local _required=false
        local _choices=''
        local _default=$ARGPARSER_UNSET
        local _const=$ARGPARSER_UNSET
        local _nargs=$ARGPARSER_UNSET
        _parse_parameters \
            _to=to _check=check _action=action \
            _desc=desc _metavar=metavar _nargs=nargs _const=const \
            _default=default _required=required _choices=choices \
            -- "$@"
        # check nargs
        if [[ $_nargs = $ARGPARSER_UNSET ]]; then
            if [[ $_const = $ARGPARSER_UNSET ]]; then
                _nargs=1
            else
                _nargs='?'
            fi
        else
            local _pattern='0|\*|\?'
            if [[ $_const = $ARGPARSER_UNSET ]] && \
                    [[ $_nargs =~ $_pattern ]]; then
                argparser_error $ARGPARSER_NAME " argparser_add_option: const values not unset, nargs can not be (0|*|?): $_nargs"
            fi
        fi
        Argparser_option_to=("${Argparser_option_to[@]}" "$_to")
        Argparser_option_check=("${Argparser_option_check[@]}" "$_check")
        Argparser_option_action=("${Argparser_option_action[@]}" "$_action")
        Argparser_option_default=("${Argparser_option_default[@]}" "$_default")
        Argparser_option_const=("${Argparser_option_const[@]}" "$_const")
        Argparser_option_nargs=("${Argparser_option_nargs[@]}" "$_nargs")
        Argparser_option_desc=("${Argparser_option_desc[@]}" "$_desc")
        Argparser_option_metavar=("${Argparser_option_metavar[@]}" "$_metavar")
        Argparser_option_required=("${Argparser_option_required[@]}" "$_required")
        Argparser_option_choices=("${Argparser_option_choices[@]}" "$_choices")
	}

	function argparser_parse()
	{
        # add help option here
        if [[ $Argparser_add_help = true ]]; then
            argparser_add_option -h --help desc="show this help message and exit"
        fi
	}

    function _choose_metavar()
    {
        :
    }

    function _choose_to()
    {
        :
    }

	function argparser_DEBUG()
	{
		:
	}

	# check API
	# check_callback arg...

	# action API
	# action_callback to value option_string option_strings
    # store|help|?version?

	# stop parsing marker --

}

# dynamically set $variable_name($1)=$values($2...) to globals scope
function _set2globals()
{
    if (( $# < 2 )); then
        printf 'Expect at least 2 argument, but %d you given.' $# >&2
        exit 1
    fi
    local _pattern='^[_a-zA-Z][_0-9a-zA-Z]*$'
    if [[ ! $1 =~ $_pattern ]]; then
        printf 'Invalid variable name: %s\n' "$1" >&2
        exit 1
    fi
    local __variable__name__=$1
    shift
    local i
    local _tmp
    local values=()
    for i in "$@"; do
        _tmp=\'${1//"'"/"'\''"}\'
        values=("${values[@]}" "$_tmp") # push to array
    done

    eval $__variable__name__=\("${values[@]}"\)
}