ARGPARSER_NAME=argparser

# data structure
ARGPARSER_UNSET=__unset___
___values__=$ARGPARSER_UNSET
___shift__num__=0
# option_status 
# 0: Positional Parameter(pp) do not show up in $@, so haven't been parsed
# 2: pp have been parsed
# 1: Optional Parameter(op) haven't been parsed
# 3: op have been parsed
ARGPARSER_PA_NO_PARSE=0
ARGPARSER_PA_PARSED=2
ARGPARSER_OA_NO_PARSE=1
ARGPARSER_OA_PARSED=3
# argparser
Argparser_prog_name=$(basename $0)
Argparser_overwrited_help=false
Argparser_prefix_chars='-'
Argparser_nargs_extending_EOT='-'
Argparser_prologue=''
Argparser_usage_string=''
Argparser_description=''
Argparser_epilog=''
Argparser_add_help=true

function argparser()
{
    # option parameters array
    Argparser_argument_strings=()
    Argparser_argument_dest=()
    Argparser_argument_check=()
    Argparser_argumentaction=()
    Argparser_argument_default=()
    Argparser_argument_const=()
    Argparser_argument_nargs=()
    Argparser_argument_desc=()
    Argparser_argument_metavar=()
    Argparser_argument_required=()
    Argparser_argument_choices=()
    Argparser_argument_pos=()
    _Argparser_argument_status=()
    # keys of positional argument with pos
    _Argparser_argument_with_pos_keys=()
    # arguments after `--`
    Argparser_du_hyphen_args=()

	function _parse_parameters()
	{
		local i
		# fetch argparser_to_argument_name_pair name
		local argparser_to_argument_name_pair=()
		local _pattern='^[_a-zA-Z][_0-9a-zA-Z]*=[_0-9a-zA-Z]*$'
		for i in "$@"; do
			shift
			if [[ $i = -- ]]; then
				break
			fi
			if [[ ! $i =~ $_pattern ]]; then
				argparser_error $ARGPARSER_NAME "invalid parameter: $i" fatal
			fi
			argparser_to_argument_name_pair=("${argparser_to_argument_name_pair[@]}" "${i/=/ }")
		done
		# parse start
		local _has_get_flag
		for argv in "$@"; do
			_has_get_flag=false
			for i in "${argparser_to_argument_name_pair[@]}"; do
				read to_name opt_name <<< "$i"
				if [[ $argv = $opt_name=* ]]; then
					_globals_register arbitrary "$to_name" "${argv#*=}"
					_has_get_flag=true
					break
				fi
			done
			[[ $_has_get_flag = false ]] && argparser_error $ARGPARSER_NAME "un-capturable argument for your argparser: $argv." error
		done
	}

	function argparser_error()
	{
		local prog=$1
		local message=$2
		local error_type=$(tr [A-Z] [a-z] <<< "${3:-error}")
		local no_exit=$4
		printf "$prog: $error_type: "'%s\n' "$message" >&2
		[[ $no_exit ]] || exit 1
	}

	function argparser_add_arg()
	{
        # fetch option name
        local _is_positional=false
		local _pattern='^[-_0-9a-zA-Z]+$'
		local optional_string=''
		while (( $# > 0 )); do
			[[ $1 = *=* ]] && break
			if [[ ! $1 =~ $_pattern ]]; then
				argparser_error $ARGPARSER_NAME "Invalid option name: $1" error
			fi
            if [[ $_is_positional = true ]]; then
                argparser_error $ARGPARSER_NAME "argparser_add_arg: too many positional argument: $1."
            fi
            if _is_positional_argment "$1"; then
                _is_positional=true
            fi
			optional_string="$optional_string|$1"
			shift
		done
        optional_string=${optional_string#|}
        Argparser_argument_strings=("${Argparser_argument_strings[@]}" "$optional_string")

        # fetch other option data
        local dest=''
        local check=argparser_check
        local action=argparser_store
        local desc=''
        local metavar=$ARGPARSER_UNSET
        local required=false
        local choices=''
        local default=$ARGPARSER_UNSET
        local const=$ARGPARSER_UNSET
        local nargs=$ARGPARSER_UNSET
        _parse_parameters \
            dest=dest check=check action=action \
            desc=desc metavar=metavar nargs=nargs const=const \
            default=default required=required choices=choices \
            -- "$@"
        # positional argument not support const/requied
        if [[ $_is_positional = true  && ! ($const = $ARGPARSER_UNSET && $required = false) ]]; then
            argparser_error $ARGPARSER_NAME "argparser_add_arg: $optional_string: positional argument do not support const/requied option."
        fi
        # dest must be an valid variable name
        local _pattern='^[_a-zA-Z][_0-9a-zA-Z]*$'
        if [[ $dest != '' && ! $dest =~ $_pattern ]]; then
            argparser_error $ARGPARSER_NAME " argparser_add_arg: ${optional_string//|/ }: dest must be a valid variable name: $dest."
        fi
        # check nargs and set nargs=remain
        if [[ $nargs = $ARGPARSER_UNSET ]]; then
            if [[ $_is_positional = true ]]; then
                # define nargs of positional argument
                if [[ $default = $ARGPARSER_UNSET ]]; then
                    nargs=1
                else
                    nargs='?'
                fi
            else
                # define nargs of positional argument
                if [[ $const = $ARGPARSER_UNSET ]]; then
                    nargs=1
                else
                    nargs='?'
                fi
            fi
        else
            _pattern='^\?|\*|\+|remain|[1-9][0-9]*|0$'
            [[ ! $nargs =~ $_pattern ]] && \
                argparser_error $ARGPARSER_NAME " ${optional_string//|/ }: nargs must be in (?|*|+|remain|[number])."
            _pattern='^0|\*|\?$'
            if [[ $const = $ARGPARSER_UNSET ]] && \
                    [[ $nargs =~ $_pattern ]]; then
                argparser_error $ARGPARSER_NAME " argparser_add_arg: $optional_string: const values not unset, nargs can not be (0|*|?): $nargs"
            fi
        fi
        # action must be callable
        if ! _is_callback; then
            argparser_error $ARGPARSER_NAME " argparser_add_arg: $optional_string: action must be callable: $action"
        fi
        # check must be callable
        if ! _is_callback; then
            argparser_error $ARGPARSER_NAME " argparser_add_arg: $optional_string: check must be callable: $check"
        fi

        Argparser_argument_dest=("${Argparser_argument_dest[@]}" "$dest")
        Argparser_argument_check=("${Argparser_argument_check[@]}" "$check")
        Argparser_argument_action=("${Argparser_argument_action[@]}" "$action")
        Argparser_argument_default=("${Argparser_argument_default[@]}" "$default")
        Argparser_argument_const=("${Argparser_argument_const[@]}" "$const")
        Argparser_argument_nargs=("${Argparser_argument_nargs[@]}" "$nargs")
        Argparser_argument_desc=("${Argparser_argument_desc[@]}" "$desc")
        Argparser_argument_metavar=("${Argparser_argument_metavar[@]}" "$metavar")
        Argparser_argument_required=("${Argparser_argument_required[@]}" "$required")
        Argparser_argument_choices=("${Argparser_argument_choices[@]}" "$choices")
	}

    function _is_callback()
    {
        hash "$check" 1>/dev/null 2>&1
    }

    function _is_optional_argment()
    {
        ((${#1} > 1)) && [[ $Argparser_prefix_chars =~ ${1:0:1} ]]
    }

    function _is_positional_argment()
    {
        [[ ! $Argparser_prefix_chars =~ ${1:0:1} ]]
    }

    function _is_long_option()
    {
        local prefix1=${1:0:1}
        local prefix2=${1:1:1}
        ((${#1} > 2)) && \
            [[ $Argparser_prefix_chars =~ $prefix1 ]] &&\
            [[ "$prefix1" = "$prefix2" ]]
    }

	function argparser_parse()
	{
        _prepare_argparser_aguments
        # find hyphen command-line args
        local ___i_=0 # for excape set2globals
        local ___args_=()
        while (($# > 0)); do
            if [[ $1 = '--' ]]; then
                shift
                break
            fi
            ___args_[$___i_]=$1
            shift
            ((___i_++))
        done
        Argparser_du_hyphen_args=("$@")
        set -- "${___args_[@]}"
        
        # parsing arguments
        while (($# > 0)); do
            if _is_optional_argment "$1"; then
                if _is_long_option "$1"; then
                    _parse_long_option "$@" && shift $___shift__num__
                else
                    _parse_short_option "$@" && shift $___shift__num__
                fi
            else
                _parse_positional_arg "$@" && shift $___shift__num__
            fi
        done

        # final check unparsed args
        _final_check_argparser_aguments
        _globals_register dump
	}

    # 1. set all arguments status to NO_PARSE
    function _prepare_argparser_aguments()
    {
        local key argument_strings
        for ((key=0; key <= ${#Argparser_argument_strings[@]}; key++)); do
            # set all arguments status to NO_PARSE
            argument_strings=${Argparser_argument_strings[$key]}
            if _is_positional_argment "$argument_strings"; then
                _Argparser_argument_status[$key]=$ARGPARSER_PA_NO_PARSE
            else
                _Argparser_argument_status[$key]=$ARGPARSER_OA_NO_PARSE
            fi
        done
    }

    function _final_check_argparser_aguments()
    {
        local key status
        for ((key=0; key <= ${#_Argparser_argument_status[@]}; key++)); do
            status=${#_Argparser_argument_status[$key]}
            if [[ $status = [$ARGPARSER_OA_NO_PARSE$ARGPARSER_PA_NO_PARSE] ]]; then
                :
            fi
        done
    }

    # parse the first long optional arguments
    # echo shift_num
    # used by argparser_parse
    function _parse_long_option()
    {
        _reset_values_and_shift_num
        local shift_num=0
        local option_string=$1
        shift
        ((shift_num++))

        local sticking_value=$ARGPARSER_UNSET
        if [[ $option_string = *=* ]]; then
            sticking_value=${option_string#*=}
            option_string=${option_string%%=*}
        fi
        local key=$(_get_argparser_optional_arg_key "$option_string" $ARGPARSER_OA_NO_PARSE)
        if [[ $key = '' ]]; then
            argparser_error $Argparser_prog_name "unrecognized argument: $option_string"
        fi
        local nargs="${Argparser_argument_nargs[$key]}"
        if [[ $nargs = 0 ]]; then
            if [[ $sticking_value != $ARGPARSER_UNSET ]]; then
                argparser_error $Argparser_prog_name "$option_string not need values: $option_string=$sticking_value"
            fi
            dest=$(_choose_dest "${Argparser_argument_dest[$key]}" "${Argparser_argument_strings[$key]}")
            _globals_register register "$dest" "${Argparser_argument_const[$key]}"
            _Argparser_argument_status[$key]=$ARGPARSER_OA_PARSED
            ___shift__num__=$shift_num
            return 0
        fi

        if [[ $sticking_value = $ARGPARSER_UNSET ]]; then
            _get_cl_arg_values $nargs "$@"
            ((shift_num+=$___shift__num__))
        else
            if [[ $nargs = 0 ]]; then
                argparser_error $Argparser_prog_name "argument $option_string not need values: $option_string=$sticking_value"
            fi
            _get_cl_arg_values "$nargs" "$sticking_value" "$@"
            (( shift_num+=($___shift__num__ - 1) ))
        fi
        # set the values to $@
        set -- "${___values__[@]}"
        # whether values count matches nargs
        _check_value_narg_matching "$nargs" "$option_string" "$@"

        _set_value2dest $key "$option_string" "$@"
        # this argument has been parsed
        _Argparser_argument_status[$key]=$ARGPARSER_OA_PARSED
        ___shift__num__=$shift_num
    }

    # parse the first short optional arguments
    # echo shift_num
    # used by argparser_parse
    function _parse_short_option()
    {
        _reset_values_and_shift_num
        local shift_num=0
        local command_line_1st_arg=$1
        shift
        ((shift_num++))
        local sticking_value=$ARGPARSER_UNSET

        # parse short option like -abcValue
        local key nargs arg_string dest _option_string _arg_residues
        while ((${#command_line_1st_arg} > 2)); do
            _option_string=${command_line_1st_arg:0:2}
            _arg_residues=${command_line_1st_arg:2}
            key=$(_get_argparser_optional_arg_key "$_option_string" $ARGPARSER_OA_NO_PARSE)
            if [[ $key = '' ]]; then
                argparser_error $Argparser_prog_name "unrecognized argument: $_option_string"
            fi
            nargs=${Argparser_argument_nargs[$key]}
            if [[ $nargs = 0 ]]; then
                dest=$(_choose_dest "${Argparser_argument_dest[$key]}" "${Argparser_argument_strings[$key]}")
                _globals_register register "$dest" "${Argparser_argument_const[$key]}"
                # this argument has been parsed
                _Argparser_argument_status[$key]=$ARGPARSER_OA_PARSED
                # rebuilt command_line_1st_arg
                command_line_1st_arg='-'$_arg_residues
            else
                command_line_1st_arg=$_option_string
                sticking_value=$_arg_residues
                break
            fi
        done

        # parsing starts
        local option_string=$command_line_1st_arg
        key=$(_get_argparser_optional_arg_key "$option_string" $ARGPARSER_OA_NO_PARSE)
        if [[ $key = '' ]]; then
            argparser_error $Argparser_prog_name "unrecognized argument: $option_string"
        fi
        nargs="${Argparser_argument_nargs[$key]}"
        if [[ $nargs = 0 ]]; then
            if [[ $sticking_value != $ARGPARSER_UNSET ]]; then
                argparser_error "$ARGPARSER_NAME" "$FUNCNAME: short optional $option_string shouldn't contain sticking value-$sticking_value-when its nargs=$nargs." 'internal fatal'
            fi
            dest=$(_choose_dest "${Argparser_argument_dest[$key]}" "${Argparser_argument_strings[$key]}")
            _globals_register register "$dest" "${Argparser_argument_const[$key]}"
            _Argparser_argument_status[$key]=$ARGPARSER_OA_PARSED
            ___shift__num__=$shift_num
            return 0
        fi

        if [[ $sticking_value = $ARGPARSER_UNSET ]]; then
                _get_cl_arg_values $nargs "$@"
                ((shift_num+=$___shift__num__))
        else
            if [[ $nargs = 0 ]]; then
                argparser_error $Argparser_prog_name "$option_string not need values: $option_string=$sticking_value"
            fi
            _get_cl_arg_values $nargs "$sticking_value" "$@"
            (( shift_num+=($___shift__num__ - 1) ))
        fi
        # set the values to $@
        set -- "${___values__[@]}"
        # whether values count matches nargs
        _check_value_narg_matching "$nargs" "$option_string" "$@"

        _set_value2dest $key "$option_string" "$@"
        # this argument has been parsed
        _Argparser_argument_status[$key]=$ARGPARSER_OA_PARSED
        ___shift__num__=$shift_num
    }

    function _parse_positional_arg()
    {
        local shift_num=0
        local key status
        key=$(_get_argparser_positional_arg_key "$ARGPARSER_PA_NO_PARSE")
        if [[ $key = '' ]]; then
            argparser_error $Argparser_prog_name "unrecognized argument: $1"
        fi
        local nargs=${Argparser_argument_nargs[$key]}
        _get_cl_arg_values $nargs "$@"
        (($___shift__num__ == 0)) && \
            argparser_error $ARGPARSER_NAME "$FUNCNAME: shift number can not be 0." 'internal fatal'
        ((shift_num+=$___shift__num__))
        set -- "${___values__[@]}"
        local metavar=$(_choose_metavar \
                        "${Argparser_argument_metavar[$key]}" \
                        "${Argparser_argument_dest[$key]}" \
                        "${Argparser_argument_strings[$key]}")
        _check_value_narg_matching "$nargs" "$option_string" "$@"
        _set_value2dest $key "$option_string" "$@"
        # this argument has been parsed
        _Argparser_argument_status[$key]=$ARGPARSER_PA_PARSED
        ___shift__num__=$shift_num
    }

    # - $1: nargs
    # - $2: error identifer: command-line optional string for optional argument; meteavar for positional argument
    # - $3...: values
    function _check_value_narg_matching()
    {
        local nargs=$1
        local error_identifer=$2
        local ignore_pattern='^\*|\?|remain$'
        shift 2
        local _pattern='^[1-9][0-9]*$'
        if [[ $nargs =~ $_pattern ]]; then
            if [[ $# != $nargs ]]; then
                argparer_usage
                argparser_error $Argparser_prog_name "argument $error_identifer: expected $nargs arguments, but just $# you supplied: $1 ... ."
            fi
        elif [[ $nargs = '+' ]]; then # only used for optional argument
            if (($# < 1)); then
                argparer_usage
                argparser_error $Argparser_prog_name "argument $error_identifer: expected at least 1 argument."
            fi
        elif [[ $nargs =~ $ignore_pattern ]]; then
            : # do nothing
        else
            argparser_error $ARGPARSER_NAME "$FUNCNAME: invalid nargs: $nargs." 'internal fatal'
        fi
    }

    # - $1: key
    # - $2: command_line_option_string
    # - $?...: values
    function _set_value2dest()
    {
        local key=$1
        local command_line_option_string=$2
        shift 2
        local arg_strings=${Argparser_argument_strings[$key]}
        local dest=$(_choose_dest "${Argparser_argument_dest[$key]}" "$arg_strings")
        if (($# == 0)); then
            _globals_register register "$dest" "$Argparser_argument_const[$key]"
        else
            local _v
            # is in choices?
            local choices="${Argparser_argument_choices[$key]}"
            if [[ $choices != '' ]]; then
                local _pattern=\^$choices\$
                for _v in "$@"; do
                    [[ $_v =~ $_pattern ]] || \
                        argparser_error $Argparser_prog_name "$command_line_option_string: $_v not in [$choices]" choices_error
                done
            fi
            # check values
            local check="${Argparser_argument_check[$key]}"
            $check "$@"
            # action; default store the value
            local action="${Argparser_argument_action[$key]}"
            $action "$dest" "$command_line_option_string" "$arg_strings" - - - "$@"
        fi
    }

    # fake check, always return true
    # - $1...: values of the argparser argument gotten
    function argparser_check() { :; }

    # get the command-line-arg matching argparser optional argument index(key)
    # - $1: command line optional string
    # - $2...: status from _Argparser_argument_status
    function _get_argparser_optional_arg_key()
    {
        local cl_arg=$1
        shift
        local status=$*
        if [[ $status = '' ]]; then
            status=$ARGPARSER_OA_PARSED$ARGPARSER_OA_NO_PARSE
        fi
        local key _option_pattern
        for ((key=0; key < ${#_Argparser_argument_status[@]}; key++)); do
            if [[ ${_Argparser_argument_status[$key]} = [$status] ]]; then
                _option_pattern='^'${Argparser_argument_strings[$key]}'$'
                if [[ $cl_arg =~ $_option_pattern ]]; then
                    echo $key
                    return
                fi
            fi
        done
    }

    # get the first argparser positional argument index
    # - $1...: status from _Argparser_argument_status
    function _get_argparser_positional_arg_key()
    {
        local status=$*
        if [[ $status = '' ]]; then
            status=$ARGPARSER_PA_PARSED$ARGPARSER_PA_NO_PARSE
        fi
        for ((key=0; key < ${#_Argparser_argument_status[@]}; key++)); do
            if [[ ${_Argparser_argument_status[$key]} = [$status] ]]; then
                echo $key
                return
            fi
        done
    }

    # get values from command line arguments by nargs
    # - $1: nargs
    # - $2...: command line args
    # set to ___values__
    function _get_cl_arg_values()
    {
        _reset_values_and_shift_num
        local values=()
        local shift_num=0
        local nargs=$1
        shift
        if [[ $nargs = '?' ]]; then
            if _is_positional_argment "$1"; then
                values=("$1")
                shift_num=1
            fi
        elif [[ $nargs = ['*+'] ]]; then
            _get_extending_values "$@" &&\
            values=("${___values__[@]}")
            shift_num=$___shift__num__
        elif [[ $nargs = 'remain' ]]; then
            values=("$@")
            shift_num=$#
        elif [[ $nargs > 0 ]]; then
            local value_len=0
            while (($# > 0)); do
                if _is_positional_argment "$1"; then
                    values=("${values[@]}" "$1")
                    value_len=${#values[@]}
                    if [[ $value_len == $nargs ]]; then
                        break
                    fi
                    shift
                else
                    break
                fi
            done
            shift_num=$value_len
        else
            argparser_error $ARGPARSER_NAME "$FUNCNAME: invalid nargs: $nargs." 'internal fatal'
        fi
        ___values__=("${values[@]}")
        ___shift__num__=$shift_num
    }

    function _reset_values_and_shift_num()
    {
        ___values__=$ARGPARSER_UNSET
        ___shift__num__=0
    }

    # get values for the nargs=*|+ arguments
    # - $1...: command-line args
    function _get_extending_values()
    {
        _reset_values_and_shift_num
        # scaning
        local has_extending_EOT=false
        local are_all_args_positional=true
        local shift_num=0
        local values=()
        # check if has_extending_EOT and are_all_args_positional
        while (($# > 0)); do
            if [[ $1 = $Argparser_nargs_extending_EOT ]]; then
                has_extending_EOT=true
                shift
                while (($# > 0)); do
                    if _is_optional_argment "$1"; then
                        are_all_args_positional=false
                        break
                    fi
                    shift
                done
                break
            elif _is_optional_argment "$1"; then
                are_all_args_positional=false
                break
            else
                values=("${values[@]}" "$1")
                shift
            fi
        done
        # get values
        if [[ $has_extending_EOT = false && $are_all_args_positional = true ]]; then
            local reserved_num=$(_cl_arg_amount_need2reserved_now)
            local value_len=${#values[@]}
            if (($value_len > $reserved_num > 0)); then
                values=("${values[@]:0:$(($value_len - $reserved_num))}")
            fi
        fi
        shift_num=${#values[@]}
        if [[ $has_extending_EOT = true ]]; then
            ((shift_num++))
        fi
        ___shift__num__=$shift_num
        ___values__=("${values[@]:0:$value_len}")
    }

    # calculate how much argparser argument nargs(only number type nargs) needing to reserved
    function _cl_arg_amount_need2reserved_now()
    {
        local key nargs status
        local reserved_num=0
        local _pattern='^[0-9]+$'
        for ((key=0; key < ${#_Argparser_argument_status[@]}; key++)); do
            status=${_Argparser_argument_status[$key]}
            nargs=${Argparser_argument_nargs[$key]}
            if [[ $status = $ARGPARSER_PA_NO_PARSE ]] &&\
                    [[ $nargs =~ $_pattern ]]; then
                    ((reserved_num+=$nargs))
            fi
        done
        echo $reserved_num
    }

    # format help string, print it and exit
    function argparser_help()
    {
        echo 'This a help msg.'
    }

    function argparer_usage()
    {
        echo 'this is an usage msa.'
    }

    function _format_usge()
    {
        # choose metavar
        Argparser_argument_metavar[$_key]=$(_choose_metavar "$metavar" "$dest" "$arg_string")
        local _key arg_status optional_string is_required
        # optional arguments
        for ((_key=0; _key < ${#_Argparser_argument_status[@]}; _key++)); do
            arg_status=${_Argparser_argument_status[$_key]}
            if [[ $arg_status = $ARGPARSER_PA_PARSED || $arg_status = $ARGPARSER_PA_NO_PARSE ]]; then
                continue
            fi
            optional_string=$(_choose_shortest_optional_string "${Argparser_argument_strings[$_key]}")
            is_required=${Argparser_argument_required[$_key]}
            if [[ $is_required = true ]]; then
                optional_string="[$optional_string]"
            fi
        done
    }

    function _choose_shortest_optional_string()
    {
        local optional_strings=(${1//'|'/ })
        local shortest_one
        set -- "${optional_strings[@]}"
        shortest_one=$1
        shift
        while (($# > 0)); do
            if ((${#shortest_one} > ${#1})); then
                shortest_one=$1
            fi
            shift
        done
        echo "$shortest_one"
    }



    # action API
    # action_callback dest option_string option_strings - - value
    # store|help|?version?
    # argparser action
    # - $1: dest
    # - $2: command-line argument string
    # - $3: argparser argument string
    # - $4:  reserved
    # - $5:  reserved
    # - $6:  reserved
    # - $7...: values
    function argparser_store()
    {
        local dest=$1
        shift 6
        _globals_register register "$dest" "$@"
    }

    # - $1: metavar
    # - $2: dest
    # - $3: argparser argument strings
    function _choose_metavar()
    {
        : 
        #_choose_metavar "$metavar" "$dest" "$arg_string"
    }

    # - $1: dest
    # - $2: argparser argument strings
    function _choose_dest()
    {
        local dest=$1
        if [[ $dest != '' ]]; then
            echo "$dest"
        else
            shift
            local arg_strings=("${1//|/ }")
            local _pattern='^[_a-zA-Z][_0-9a-zA-Z]*$'
            set -- "${arg_strings[@]}"
            dest=''
            while (($# > 0)); do
                _dest=$(_trim_option_prefixs "$1")
                shift
                if ((${#dest} < ${#_dest})) && [[ $_dest =~ $_pattern ]]; then
                    dest=$_dest
                fi
            done
            echo "$dest"
        fi
    }

    function _trim_option_prefixs()
    {
        if _is_optional_argment "$1"; then
            if _is_long_option "$1"; then
                echo "${1:2}"
            else
                echo "${1:1}"
            fi
        else
            echo "$1"
        fi
    }

	function argparser_DEBUG()
	{
		:
	}


    # register variable declaring literal into an globals scope
    # - $1: action: register|dump|arbitrary|dry_dump
    # - $2: variable name
    # - $3...: values
    function _globals_register()
    {
        # The global register's globals variable
        ###  __Globals_Register_Variable_Declaring_Literal__  ###
        local action__=$1
        shift
        if [[ $action__ = 'register' || $action__ = 'arbitrary' ]]; then
            if (( $# < 2 )); then
                argparser_error "ARGPARSER_NAME" "$FUNCNAME $action__: expected 2 arguments."
            fi
            local variable_name__=$1
            local pattern__='^[_a-zA-Z][_0-9a-zA-Z]*$'
            if [[ ! $1 =~ $pattern__ ]]; then
                argparser_error "ARGPARSER_NAME" "$FUNCNAME $action__: invalid variable name: $1."
            fi
            shift
            local v__
            local values__=()
            while (($# > 0)); do
                v__=\'${1//"'"/"'\''"}\'
                values__=("${values__[@]}" "$v__") # push to array
                shift
            done
            # arbitrarily set the value to variable
            if [[ $action__ = 'arbitrary' ]]; then
                eval $variable_name__=\("${values__[@]}"\)
                return 0
            fi
            # register to global literal
            local declaring_literal=$variable_name__=\("${values__[@]}"\)$'\n'
            __Globals_Register_Variable_Declaring_Literal__+=$declaring_literal
        elif [[ $action__ = 'dump' ]]; then
            if [[ $__Globals_Register_Variable_Declaring_Literal__ = '' ]]; then
                argparser_error "ARGPARSER_NAME" "$FUNCNAME $action__: nothing to be dumped."
            fi
            eval "$__Globals_Register_Variable_Declaring_Literal__"
            unset __Globals_Register_Variable_Declaring_Literal__
        elif [[ $action__ = 'dry_dump' ]]; then
            unset __Globals_Register_Variable_Declaring_Literal__
        else
            argparser_error "ARGPARSER_NAME" "$FUNCNAME: invalid action__: $action__." fatal
        fi
    }

	# check API
	# check_callback arg...


	# stop parsing marker --

    # initial argparser
    if (( $# > 0 )); then
        Argparser_prog_name=$1
        shift
        if (( $# > 0 )); then
            _parse_parameters \
                Argparser_overwrited_help=overwrited_help \
                Argparser_prologue=prologue \
                Argparser_usage_string=usage_string \
                Argparser_description=description \
                Argparser_epilog=epilog \
                Argparser_prefix_chars=prefix_chars \
                Argparser_add_help=add_help \
                Argparser_nargs_extending_EOT=nargs_extending_EOT \
                -- "$@"
        fi
    fi
    # add help option here
    if [[ $Argparser_add_help = true ]]; then
        argparser_add_arg -h --help desc="show this help message and exit" action=argparser_help
    fi
    # -- initial argparser done
}