ARGPARSER_NAME=argparser

# data structure
ARGPARSER_UNSET=__unset___
___values__=$ARGPARSER_UNSET
# option_status 
# 0: Positional Parameter(pp) do not show up in $@, so haven't been parsed
# 2: pp have been parsed
# 1: Optional Parameter(op) haven't been parsed
# 3: op have been parsed
ARGPARSER_PA_NO_PARSE=0
ARGPARSER_PA_PARSED=2
ARGPARSER_OA_NO_PARSE=1
ARGPARSER_OA_PARSED=3
# argparser
Argparser_prog_name=$(basename $0)
Argparser_overwrited_help=false
Argparser_prefix_chars=-
Argparser_prologue=''
Argparser_usage_string=''
Argparser_description=''
Argparser_epilog=''
Argparser_add_help=true

function argparser()
{
    # option parameters array
    Argparser_argument_strings=()
    Argparser_argument_to=()
    Argparser_argument_check=()
    Argparser_argument_action=()
    Argparser_argument_default=()
    Argparser_argument_const=()
    Argparser_argument_nargs=()
    Argparser_argument_desc=()
    Argparser_argument_metavar=()
    Argparser_argument_required=()
    Argparser_argument_choices=()
    Argparser_du_hyphen_args=()
    _Argparser_argument_status=()

	function _parse_parameters()
	{
		local i
		# fetch argparser_to_argument_name_pair name
		local argparser_to_argument_name_pair=()
		local _pattern='^[_a-zA-Z][_0-9a-zA-Z]*=[_0-9a-zA-Z]*$'
		for i in "$@"; do
			shift
			if [[ $i = -- ]]; then
				break
			fi
			if [[ ! $i =~ $_pattern ]]; then
				argparser_error $ARGPARSER_NAME "invalid parameter: $i" fatal
			fi
			argparser_to_argument_name_pair=("${argparser_to_argument_name_pair[@]}" "${i/=/ }")
		done
		# parse start
		local _has_get_flag
		for argv in "$@"; do
			_has_get_flag=false
			for i in "${argparser_to_argument_name_pair[@]}"; do
				read to_name opt_name <<< "$i"
				if [[ $argv = $opt_name=* ]]; then
					_set2globals "$to_name" "${argv#*=}"
					_has_get_flag=true
					break
				fi
			done
			[[ $_has_get_flag = false ]] && argparser_error $ARGPARSER_NAME "un-capturable argument for your argparser: $argv." error
		done
	}

	function argparser_error()
	{
		local prog=$(tr [a-z] [A-Z] <<< "$1")
		local message=$2
		local error_type=$(tr [A-Z] [a-z] <<< "${3:-error}")
		local no_exit=$4
		printf "$prog: $error_type: "'%s\n' "$message" >&2
		[[ $no_exit ]] || exit 1
	}

    #@to-do add exclusive type
	function argparser_add_arg()
	{
        # fetch option name
        local _status=$ARGPARSER_OA_NO_PARSE
        local _is_positional=false
		local _pattern='^[-_0-9a-zA-Z]+$'
		local optional_string=''
		while (( $# > 0 )); do
			[[ $1 = *=* ]] && break
			if [[ ! $1 =~ $_pattern ]]; then
				argparser_error $ARGPARSER_NAME "Invalid option name: $1" error
			fi
            if [[ $_is_positional = true ]]; then
                argparser_error $ARGPARSER_NAME "argparser_add_arg: too many positional argument: $1."
            fi
            if _is_positional_argment "$1"; then
                _is_positional=true
                _status=$ARGPARSER_PA_NO_PARSE
            fi
			optional_string="$optional_string|$1"
			shift
		done
        optional_string=${optional_string#|}
        Argparser_argument_strings=("${Argparser_argument_strings[@]}" "$optional_string")

        # fetch other option data
        local _to=''
        local _check=argparser_check
        local _action=argparser_store
        local _desc=''
        local _metavar=$ARGPARSER_UNSET
        local _required=false
        local _choices=''
        local _default=$ARGPARSER_UNSET
        local _const=$ARGPARSER_UNSET
        local _nargs=$ARGPARSER_UNSET
        _parse_parameters \
            _to=to _check=check _action=action \
            _desc=desc _metavar=metavar _nargs=nargs _const=const \
            _default=default _required=required _choices=choices \
            -- "$@"
        # positional argument not support const/requied
        if [[ $_is_positional = true  && ! ($_const = $ARGPARSER_UNSET && $_required = false) ]]; then
            argparser_error $ARGPARSER_NAME "argparser_add_arg: positional argument do not support const/requied option."
        fi
        # check nargs
        if [[ $_nargs = $ARGPARSER_UNSET ]]; then
            if [[ $_is_positional = true ]]; then
                # define nargs of positional argument
                if [[ $_default = $ARGPARSER_UNSET ]]; then
                    _nargs=1
                else
                    _nargs='?'
                fi
            else
                # define nargs of positional argument
                if [[ $_const = $ARGPARSER_UNSET ]]; then
                    _nargs=1
                else
                    _nargs='?'
                fi
            fi
        else
            local _pattern='0|\*|\?'
            if [[ $_const = $ARGPARSER_UNSET ]] && \
                    [[ $_nargs =~ $_pattern ]]; then
                argparser_error $ARGPARSER_NAME " argparser_add_arg: $optional_string: const values not unset, nargs can not be (0|*|?): $_nargs"
            fi
        fi
        # action
        if hash "$_action" 1>/dev/null 2>&1; then
            argparser_error $ARGPARSER_NAME " argparser_add_arg: $optional_string: action must be callable: $_action"
        fi
        # check must be callable
        if hash "$_check" 1>/dev/null 2>&1; then
            argparser_error $ARGPARSER_NAME " argparser_add_arg: $optional_string: check must be callable: $_check"
        fi

        Argparser_argument_to=("${Argparser_argument_to[@]}" "$_to")
        Argparser_argument_check=("${Argparser_argument_check[@]}" "$_check")
        Argparser_argument_action=("${Argparser_argument_action[@]}" "$_action")
        Argparser_argument_default=("${Argparser_argument_default[@]}" "$_default")
        Argparser_argument_const=("${Argparser_argument_const[@]}" "$_const")
        Argparser_argument_nargs=("${Argparser_argument_nargs[@]}" "$_nargs")
        Argparser_argument_desc=("${Argparser_argument_desc[@]}" "$_desc")
        Argparser_argument_metavar=("${Argparser_argument_metavar[@]}" "$_metavar")
        Argparser_argument_required=("${Argparser_argument_required[@]}" "$_required")
        Argparser_argument_choices=("${Argparser_argument_choices[@]}" "$_choices")
        _Argparser_argument_status=("${_Argparser_argument_status[@]}" "$_status")
	}

    function _is_optional_argment()
    {
        [[ $Argparser_prefix_chars =~ ${1:0:1} ]]
    }

    function _is_positional_argment()
    {
        [[ ! $Argparser_prefix_chars =~ ${1:0:1} ]]
    }

	function argparser_parse()
	{
        local to
        local check
        local action
        local desc
        local metavar
        local required
        local choices
        local default
        local const
        local nargs
        local arg_status
        local argument_strings
        local _key
        # find hyphen args
        for ((_key=1; _key <= $#; _key++)); do
            _cl_arg=${@:$_key:1}
            if [[ $_cl_arg = '--' ]]; then
                break
            fi
        done
        Argparser_du_hyphen_args=("${@:$(($_key} + 1))")
        set -- "${@:1:$(($_key - 1))}"
        # scanning command-line arguments and cut the last optional argument and its arg_value
        local last_cl_args_to_last_optional
        local _cl_arg
        for ((_key=$#; _key > 0 ; _key--)); do
            _cl_arg=${@:$_key:1}
            if _is_optional_argment "$_cl_arg"; then
                break
            fi
        done
        last_cl_args_to_last_optional=("${@:$_key}")
        set -- "${@:1:$(($_key - 1))}"

        # first parsing optional arguments
        local un_parsed_cl_args=()
        while (($# > 0)); do
            if _is_optional_argment "$1"; then
                if _is_long_option "$1"; then
                    shift_num=$(_parse_long_option "$@")
                    shift $shift_num
                else
                    shift_num=$(_parse_short_option "$@")
                    shift $shift_num
                fi
            else
                un_parsed_cl_args=("${un_parsed_cl_args[@]}", "$1")
                shift
            fi
        done
	}

    # echo shift_num
    # used by argparser_parse
    function _parse_long_option()
    {
        local shift_num=0
        local command_line_arg=$1
        shift
        ((shift_num++))

        local sticking_value=$ARGPARSER_UNSET
        if [[ $command_line_arg = *=* ]]; then
            sticking_value=${command_line_arg#*=}
            command_line_arg=${command_line_arg%%=*}
        fi
        local key=$(_get_argparser_arg_key "$command_line_arg" $ARGPARSER_OA_NO_PARSE)
        if [[ $key = '' ]]; then
            argparser_error $ARGPARSER_NAME "argparser_parse: unknown argument: $command_line_arg"
        fi
        local nargs="${Argparser_argument_nargs[$key]}"
        local _n
        if [[ $sticking_value = $ARGPARSER_UNSET ]]; then
            _n=$(_get_cl_arg_values $nargs "$command_line_arg" "$@")
            ((shift_num+=$_n))
        else
            if [[ $nargs = 0 ]]; then
                argparser_error $Argparser_prog_name "$command_line_arg not need values: $command_line_arg=$sticking_value"
            fi
            _n=$(_get_cl_arg_values $nargs "$command_line_arg" "$sticking_value" "$@")
            (( shift_num+=($_n-1) ))
        fi
        # set the values to $@
        set -- "${___values__[@]}"
        local arg_string=${Argparser_argument_strings[$key]}
        local to=$(_choose_to "$to" "$arg_string")
        if (($# == 0)); then
            _set2globals $to "$Argparser_argument_const[$key]"
        else
            local _v
            # is in choices?
            local choices="${Argparser_argument_choices[$key]}"
            if [[ $choices != '' ]]; then
                local _pattern=\^$choices\$
                for _v in "$@"; do
                    [[ $_v =~ $_pattern ]] || \
                        argparser_error $Argparser_prog_name "$command_line_arg: $_v not in [$choices]" choices_error
                done
            fi
            # check values
            local check="${Argparser_argument_check[$key]}"
            $check "$@"
            # action; default store the value
            $action $to "$command_line_arg" "$arg_string" - - "$@"
        fi
        # this argument has been parsed
        _Argparser_argument_status[$key]=$ARGPARSER_OA_PARSED
    }

    # fake check, always return true
    # - $1...: values of the argparser argument gotten
    function argparser_check() { :; }

    # echo shift_num
    function _parse_short_option()
    {
        :
    }

    # get the command-line-arg matching argparser index(key)
    # - $1: command line argument string
    # - $2...: status from _Argparser_argument_status
    function _get_argparser_arg_key()
    {
        local cl_arg=$1
        shift
        local status=$*
        if [[ $status = '' ]]; then
            status=$ARGPARSER_PA_PARSED$ARGPARSER_OA_PARSED$ARGPARSER_PA_NO_PARSE$ARGPARSER_OA_NO_PARSE
        fi
        local _key _option_pattern
        for ((_key=0; _key < ${#_Argparser_argument_status[@]}; _key++)); do
            if [[ ${_Argparser_argument_status[$_key]} = [$status] ]]; then
                _option_pattern='^'${Argparser_argument_strings[$_key]}'$'
                if [[ $cl_arg =~ $_option_pattern ]]; then
                    echo $_key
                    return
                fi
            fi
        done
    }

    # get values from command line arguments by nargs
    # - $1: nargs
    # - $2: command line otpion string for error output
    # - $3...: command line args
    # - echo: num of gotten values
    # set to ___values__
    # here--
    function _get_cl_arg_values()
    {
        ___values__=()
        local nargs=$1
        local cl_option_string=$2
        shift 2
        local shift_num=0
        if [[ $nargs = '?']]; then
            if _is_positional_argment "$1"; then
                ___values__=("$1")
                ((shift_num++))
            fi
        elif [[ $nargs = '*' ]]; then
            while (($# > 0)); do
                if _is_positional_argment "$1"; then
                    ___values__=("${___values__[@]}" "$1")
                    shift
                    ((shift_num++))
                else
                    break
                fi
            done
        elif [[ $nargs = '+' ]]; then
            while (($# > 0)); do
                if _is_positional_argment "$1"; then
                    ___values__=("${___values__[@]}" "$1")
                    shift
                    ((shift_num++))
                else
                    break
                fi
            done
        elif [[ $nargs = 'remain' ]]; then
            ___values__=("$@")
            shift_num=$#
        elif (($nargs > 0)); then
            while (($# > 0)); do
                if _is_positional_argment "$1"; then
                    ___values__=("${___values__[@]}" "$1")
                    shift
                    ((shift_num++))
                    if (($shift_num == $nargs)); then
                        break
                    fi
                else
                    break
                fi
            done
        else
            argparser_error $ARGPARSER_NAME "unknown nargs: $nargs." fatal
        fi
        echo $shift_num
    }

    function _is_long_option()
    {
        :
    }

    # format help string, print it and exit
    function argparse_help()
    {
        :
    }

    function _format_usge()
    {
        # choose metavar
        Argparser_argument_metavar[$_key]=$(_choose_metavar "$metavar" "$to" "$arg_string")
        local _key arg_status optional_string is_required
        # optional arguments
        for ((_key=0; _key < ${#_Argparser_argument_status[@]}; _key++)); do
            arg_status=${_Argparser_argument_status[$_key]}
            if [[ $arg_status = $ARGPARSER_PA_PARSED || $arg_status = $ARGPARSER_PA_NO_PARSE ]]; then
                continue
            fi
            optional_string=$(_choose_shortest_optional_string "${Argparser_argument_strings[$_key]}")
            is_required=${Argparser_argument_required[$_key]}
            if [[ $is_required = true ]]; then
                optional_string="[$optional_string]"
            fi
        done
    }

    function _choose_shortest_optional_string()
    {
        local optional_strings=(${1//'|'/ })
        local shortest_one
        set -- "${optional_strings[@]}"
        shortest_one=$1
        shift
        while (($# > 0)); do
            if ((${#shortest_one} > ${#1})); then
                shortest_one=$1
            fi
            shift
        done
        echo "$shortest_one"
    }



    # action API
    # action_callback to option_string option_strings - - value
    # store|help|?version?
    # argparser action
    # - $1: to
    # - $2: command-line argument string
    # - $3: argparser argument string
    # - $4:  reserved
    # - $5:  reserved
    # - $6:  reserved
    # - $7...: values
    function argparser_store()
    {
        local to=$1
        shift 6
        _set2globals $to "$@"
    }

    function _choose_metavar()
    {
        :
    }

    # $to $arg_string
    function _choose_to()
    {
        :
    }

	function argparser_DEBUG()
	{
		:
	}

	# check API
	# check_callback arg...


	# stop parsing marker --

    # initial argparser
    if (( $# > 0 )); then
        Argparser_prog_name=$1
        shift
        if (( $# > 0 )); then
            _parse_parameters \
                Argparser_overwrited_help=overwrited_help \
                Argparser_prologue=prologue \
                Argparser_usage_string=usage_string \
                Argparser_description=description \
                Argparser_epilog=epilog \
                Argparser_prefix_chars=prefix_chars \
                Argparser_add_help=add_help \
                -- "$@"
        fi
    fi
    # add help option here
    if [[ $Argparser_add_help = true ]]; then
        argparser_add_arg -h --help desc="show this help message and exit" action=argparse_help
    fi
    # -- initial argparser done
}

# dynamically set $variable_name($1)=$values($2...) to globals scope
function _set2globals()
{
    if (( $# < 2 )); then
        printf 'Expect at least 2 argument, but %d you given.' $# >&2
        exit 1
    fi
    local _pattern='^[_a-zA-Z][_0-9a-zA-Z]*$'
    if [[ ! $1 =~ $_pattern ]]; then
        printf 'Invalid variable name: %s\n' "$1" >&2
        exit 1
    fi
    local __variable__name__=$1
    shift
    local i
    local _tmp
    local values=()
    for i in "$@"; do
        _tmp=\'${1//"'"/"'\''"}\'
        values=("${values[@]}" "$_tmp") # push to array
    done

    eval $__variable__name__=\("${values[@]}"\)
}